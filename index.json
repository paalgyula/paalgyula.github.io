[
{
	"uri": "/tutorial/",
	"title": "Tutorials",
	"tags": [],
	"description": "",
	"content": " Tutorials Section I will create a lot of tutorial and upload some examples from my projects/pilots.\n"
},
{
	"uri": "/tutorial/linux/",
	"title": "Linux Tutorials",
	"tags": [],
	"description": "",
	"content": " Linux Tutorial series  SSH Tricks   Letsencrypt Acme Nginx   Postfix DKIM   "
},
{
	"uri": "/wiki/",
	"title": "Wiki",
	"tags": [],
	"description": "",
	"content": " WIKI pages for the tutorials  Secure Shell (SSH)   Domain Name System (DNS)   Open Mail Relay   "
},
{
	"uri": "/wiki/ssh/",
	"title": "Secure Shell (SSH)",
	"tags": [],
	"description": "",
	"content": " SSH - Secure Shell SSH (Secure SHell) is an encrypted terminal program that replaces the classic telnet tool on Unix-like operating systems.\nIn addition to remote terminal access provided by the main ssh binary, the SSH suite of programs has grown to include other tools such as SCP (Secure Copy Program) and SFTP (Secure File Transfer Protocol).\nSFTP - Secure File Transfer Protocol The SSH File Transfer Protocol (also Secure File Transfer Protocol, or SFTP) is a network protocol that provides file access, file transfer, and file management over any reliable data stream. It was designed by the Internet Engineering Task Force (IETF) as an extension of the Secure Shell protocol (SSH) version 2.0 to provide secure file transfer capabilities.\nSCP - Secure Copy The SCP is a network protocol, based on the BSD RCP protocol, which supports file transfers between hosts on a network. SCP uses Secure Shell (SSH) for data transfer and uses the same mechanisms for authentication, thereby ensuring the authenticity and confidentiality of the data in transit. A client can send (upload) files to a server, optionally including their basic attributes (permissions, timestamps). Clients can also request files or directories from a server (download). SCP runs over TCP port 22 by default. Like RCP, there is no RFC that defines the specifics of the protocol.\n"
},
{
	"uri": "/tutorial/linux/easy-ssh-tricks/",
	"title": "SSH Tricks",
	"tags": [],
	"description": "",
	"content": " SSH Tweaks/tricks SSH public key authentication Introduction Public-key authentication with Secure Shell is more secure than password authentication, as it provides much stronger identity checking. An entity must possess both the private key and the correct passphrase to authenticate itself to another entity.\nGenerating your keypair be sure that ~/.ssh/id_rsa doesnt exists or this command will override it!\n ssh-keygen -t rsa -b 4096 -C \u0026quot;youremail@yourdomain.com\u0026quot;  This creates a new ssh key, using the provided email as a label.\nWhen you\u0026rsquo;re prompted to \u0026ldquo;Enter a file in which to save the key,\u0026rdquo; press Enter. This accepts the default file location.\nAt the prompt, type a secure passphrase or leave it blank for passwordless authentication. This is not recommended by myself because if someone steal your private key, he can access your resources much easily.\n"
},
{
	"uri": "/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": "Credits:\n"
},
{
	"uri": "/tutorial/linux/letsencrypt-acme-nginx/",
	"title": "Letsencrypt Acme Nginx",
	"tags": [],
	"description": "",
	"content": " Introduction This is a guide how to set up your free SSL certificate for your web-server with Letsencrypt\u0026rsquo;s acme client on an Ubuntu linux server.\nInstallation First of all we have to install the NGINX web server\nsudo apt install nginx  Next step is to install the certbot via the certbot\u0026rsquo;s lauchpad repository\nsudo apt-get install software-properties-common sudo add-apt-repository ppa:certbot/certbot sudo apt-get update sudo apt-get install certbot python-certbot-nginx  We have all dependency installed so lets configure it!\nConfiguration First step is to configure our virtualhost in nginx for example we will use example.com domain\nThe example.com is just an example you should change it to your domain name!\n lets create a new file at /etc/nginx/sites-available/example.com\nsudo nano /etc/nginx/sites-available/example.com  paste the following code:\nserver { listen 80; listen [::]:80; server_name example.com; root /var/www/example.com; index index.html; location / { try_files $uri $uri/ =404; } }  Lets create a directory for our website content:\nsudo mkdir -p /var/www/example.com  Now we can enable the site by creating symlink at NGINX\u0026rsquo;s sites-enabled folder, and restart the server:\nsudo ln -s /etc/nginx/sites-available/example.com /etc/nginx/sites-enabled/example.com sudo service nginx restart  We previously installed the certbot\u0026rsquo;s NGINX plugin so the plugin will guide us trough the configuration cycle. Lets start the client with the following command:\nsudo certbot  The certbot will find our predefined virtualhost something like this: You should type 1 (or the id of your domain) and press Enter\nAfter this there will be some question you should fill, then in the end the script will ask for what will you gonna do with the plain HTTP traffic. I suggest use the redirect method which is the 2nd option, this option will redirect all unencrypted traffic to HTTPS channel. Select 2 and then press Enter.\nIf everything is OK you should see something like:\nCongratulations! You have successfully enabled https://example.com  You\u0026rsquo;re not done! All of the certs aquired from LetsEncrypt.org expires in 3 months\n Configuring automatical renew Theres a quick solution to renew your cert automatically. The certbot client has a great command line feature which can renew your certificate with just one command: certbot renew\nNow we just need a cron script what is executing every day and checks for expired cert/certs. Create a file in /etc/cron/cron.daily called certbot-renew:\nsudo nano /etc/cron/cron.daily/certbot-renew  Paste the following content:\n#!/bin/bash certbot renew  Add the executable flag on the file:\nsudo chmod +x /etc/cron/cron.daily/certbot-renew  Congratulations, now you have finished! :)\n"
},
{
	"uri": "/tutorial/linux/postfix-opendkim/",
	"title": "Postfix DKIM",
	"tags": [],
	"description": "",
	"content": " Introduction The frustration of getting falsely flagged as a spammer is not strange to most of the mail server admins. By excluding the possibility of a compromised server, a false flag is usually caused by one of the following:\n the server is an open mail relay the sender\u0026rsquo;s or server\u0026rsquo;s IP address is blacklisted the server does not have a FQDN and a PTR record the Sender Policy Framework (SPF) DNS record is missing or it is misconfigured the DomainKeys Identified Mail (DKIM) implementation is missing or it\u0026rsquo;s not properly set up These are some of the basic properties that are being checked by the majority of proprietary and open source spam filters (including SpamAssassin). Passing these tests is extremely important for a well configured mail server.  This tutorial will focus on installing and configuring OpenDKIM: an open source implementation of the DKIM sender authentication system.\nIt is assumed that the reader knows how to access the server over SSH, Postfix and Dovecot is already installed and configured, the host name and the FQDN are set up and the SPF record is in place.\n Install OpenDKIM Before starting the installation, a system update is recommended:\nsudo apt-get update sudo apt-get dist-upgrade  Install OpenDKIM and it\u0026rsquo;s dependencies:\nsudo apt-get install opendkim opendkim-tools  Additional packages will be listed as dependencies, type yes and press Enter to continue.\nConfigure OpenDKIM A couple of files must be created and edited in order to configure OpenDKIM.\n Nano will be used as an editor we will use it as a default editor but if you don\u0026rsquo;t like it feel free to use your own command line editor (vi/mcedit) you can navigate with the arrow keys exit without saving changes: press CTRL + X and then N exit and save changes: press CTRL + X and then Y, and finally press Enter  Important: replace every instance of example.com with your own domain in all commands and configuration files. Don\u0026rsquo;t forget to save your files after editing.\n Let\u0026rsquo;s start with the main configuration file:\nsudo nano /etc/opendkim.conf  Append the following lines to the end of the conf file (each parameter is explained below). Optionally, you can choose a custom port number for the Socket. Make sure that it\u0026rsquo;s not used by a different application.\n AutoRestart Yes AutoRestartRate 10/1h UMask 002 Syslog yes SyslogSuccess Yes LogWhy Yes Canonicalization relaxed/simple ExternalIgnoreList refile:/etc/opendkim/TrustedHosts InternalHosts refile:/etc/opendkim/TrustedHosts KeyTable refile:/etc/opendkim/KeyTable SigningTable refile:/etc/opendkim/SigningTable Mode sv PidFile /var/run/opendkim/opendkim.pid SignatureAlgorithm rsa-sha256 UserID opendkim:opendkim Socket inet:12301@localhost  AutoRestart: auto restart the filter on failures AutoRestartRate: specifies the filter\u0026rsquo;s maximum restart rate, if restarts begin to happen faster than this rate, the filter will terminate; 10/1h - 10 restarts/hour are allowed at most UMask: gives all access permissions to the user group defined by UserID and allows other users to read and execute files, in this case it will allow the creation and modification of a Pid file. Syslog, SyslogSuccess, *LogWhy: these parameters enable detailed logging via calls to syslog Canonicalization: defines the canonicalization methods used at message signing, the simple method allows almost no modification while the relaxed one tolerates minor changes such as whitespace replacement; relaxed/simple - the message header will be processed with the relaxed algorithm and the body with the simple one ExternalIgnoreList: specifies the external hosts that can send mail through the server as one of the signing domains without credentials InternalHosts: defines a list of internal hosts whose mail should not be verified but signed instead KeyTable: maps key names to signing keys SigningTable: lists the signatures to apply to a message based on the address found in the From: header field Mode: declares operating modes; in this case the milter acts as a signer (s) and a verifier (v) PidFile: the path to the Pid file which contains the process identification number SignatureAlgorithm: selects the signing algorithm to use when creating signatures UserID: the opendkim process runs under this user and group Socket: the milter will listen on the socket specified here, Posfix will send messages to opendkim for signing and verification through this socket; 12301@localhost defines a TCP socket that listens on localhost, port 12301  If you want to use unix socket instead of inet ports, you have to add postfix user to opendkim group:\nsudo adduser postfix opendkim sudo service postfix restart  This simple configuration is meant to allow message signing for one or more domains, to learn about other options please go here.\n Connect the milter to Postfix:\nsudo nano /etc/default/opendkim  Add the following line, edit the port number only if a custom one is used:\nSOCKET=\u0026quot;inet:12301@localhost\u0026quot;  Configure postfix to use this milter:\nsudo nano /etc/postfix/main.cf  Make sure that these two lines are present in the Postfix config file and are not commented out:\nmilter_protocol = 2 milter_default_action = accept  It is likely that a filter (SpamAssasin, Clamav etc.) is already used by Postfix; if the following parameters are present, just append the opendkim milter to them (milters are separated by a comma), the port number should be the same as in opendkim.conf:\nsmtpd_milters = unix:/spamass/spamass.sock, inet:localhost:12301 non_smtpd_milters = unix:/spamass/spamass.sock, inet:localhost:12301  If the parameters are missing, define them as follows:\nsmtpd_milters = inet:localhost:12301 non_smtpd_milters = inet:localhost:12301  Create a directory structure that will hold the trusted hosts, key tables, signing tables and crypto keys:\nsudo mkdir /etc/opendkim sudo mkdir /etc/opendkim/keys  Specify trusted hosts:\nsudo nano /etc/opendkim/TrustedHosts  We will use this file to define both ExternalIgnoreList and InternalHosts, messages originating from these hosts, domains and IP addresses will be trusted and signed.\nBecause our main configuration file declares TrustedHosts as a regular expression file (refile), we can use wildcard patters, *.example.com means that messages coming from example.com\u0026rsquo;s subdomains will be trusted too, not just the ones sent from the root domain.\nCustomize and add the following lines to the newly created file. Multiple domains can be specified, do not edit the first three lines:\n127.0.0.1 localhost 192.168.0.1/24 *.example.com #*.example.net #*.example.org  Create a key table:\nsudo nano /etc/opendkim/KeyTable  A key table contains each selector/domain pair and the path to their private key. Any alphanumeric string can be used as a selector, in this example mail is used and it\u0026rsquo;s not necessary to change it.\nmail._domainkey.example.com example.com:mail:/etc/opendkim/keys/example.com/mail.private #mail._domainkey.example.net example.net:mail:/etc/opendkim/keys/example.net/mail.private #mail._domainkey.example.org example.org:mail:/etc/opendkim/keys/example.org/mail.private  Create a signing table:\nsudo nano /etc/opendkim/SigningTable  This file is used for declaring the domains/email addresses and their selectors.\n*@example.com mail._domainkey.example.com #*@example.net mail._domainkey.example.net #*@example.org mail._domainkey.example.org  Generate the public and private keys Change to the keys directory:\ncd /etc/opendkim/keys  Create a separate folder for the domain to hold the keys:\nsudo mkdir example.com cd example.com  Generate the keys:\nsudo opendkim-genkey -s mail -d example.com  -s specifies the selector and -d the domain, this command will create two files, mail.private is our private key and mail.txt contains the public key.\nChange the owner of the private key to opendkim user and fix permissions:\nsudo chown opendkim:opendkim mail.private sudo chown -R opendkim:opendkim /etc/opendkim sudo chmod -R go-rwx /etc/opendkim/keys  Add the public key to the domain\u0026rsquo;s DNS records Open mail.txt:\nsudo nano -$ mail.txt  The public key is defined under the p parameter. Do not use the example key below, it\u0026rsquo;s only an illustration and will not work on your server.\nmail._domainkey IN TXT \u0026quot;v=DKIM1; k=rsa; p=MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAp2SJ7b6/cIW4ljuxnFWKahEB9YnTlIC9Zk1a0J/zhoOZi3o1agMWdpV8bx0FahUFsQFjDIEJV1jITxu4ItajPq8q7JcWqfbwzz0dQHdYHN/QLLurDZWCLvbNS5PwArCsXxWZu2PAga9A9A+tf/Rzi+OTxcA/58Ky+KB4YoR6xdQTMq2RSb\u0026quot;; ----- DKIM key mail for example.com  Copy that key and add a TXT record to your domain\u0026rsquo;s DNS entries:\nName: mail._domainkey.example.com.\nText: \u0026ldquo;v=DKIM1; k=rsa; p=MIIBIjANBgkqhkiG9\u0026hellip;\u0026rdquo;\nPlease note that the DNS changes may take a couple of hours to propagate.\nSystemd service check on ubuntu you should modify the /lib/systemd/system/opendkim.service because ubuntu starts the daemon as a unix socket by default.\nThe file contains an ExecStart line which should look like this:\nExecStart=/usr/sbin/opendkim -P /var/run/opendkim/opendkim.pid -p local:/var/run/opendkim/opendkim.sock -p inet:12301@localhost  So we need to added a -p inet:12301@localhost parameter for listen on the internet socket too.\nRestarting/Testing Restart Postfix and OpenDKIM:\nsudo systemctl daemon-reload sudo service postfix restart sudo service opendkim restart  Congratulations! You have successfully configured DKIM for your mail server!\nThe configuration can be tested by sending an empty email to check-auth@verifier.port25.com and a reply will be received. If everything works correctly you should see DKIM check: pass under Summary of Results.\n========================================================== Summary of Results ========================================================== SPF check: pass DomainKeys check: neutral DKIM check: pass Sender-ID check: pass SpamAssassin check: ham  Alternatively, you can send a message to a Gmail address that you control, view the received email\u0026rsquo;s headers in your Gmail inbox, dkim=pass should be present in the Authentication-Results header field.\nAuthentication-Results: mx.google.com; spf=pass (google.com: domain of contact@example.com designates --- as permitted sender) smtp.mail=contact@example.com; dkim=pass header.i=@example.com;  "
},
{
	"uri": "/cv/",
	"title": "Paal Gyula&#39;s Personal CV",
	"tags": [],
	"description": "",
	"content": " document.location.href = '/cv/paalgyula.html'; "
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/wiki/domain-name-system/",
	"title": "Domain Name System (DNS)",
	"tags": [],
	"description": "",
	"content": " The domain name system (DNS) is the way that internet domain names are located and translated into internet protocol (IP) addresses. The domain name system maps the name people use to locate a website to the IP address that a computer uses to locate a website. For example, if someone types www.google.com into a web browser, a server behind the scenes will map that name to the IP address 216.58.213.196.\nA - Address record Returns a 32-bit IPv4 address, most commonly used to map hostnames to an IP address of the host, but it is also used for DNSBLs, storing subnet masks in RFC 1101, etc.\nAAAA - IPv6 address record Returns a 128-bit IPv6 address, most commonly used to map hostnames to an IP address of the host.\nCNAME - Canonical name record Alias of one name to another: the DNS lookup will continue by retrying the lookup with the new name.\nMX - Mail exchange record Maps a domain name to a list of message transfer agents for that domain\nNS - Name server record Delegates a DNS zone to use the given authoritative name servers\nPTR - Pointer record Pointer to a canonical name. Unlike a CNAME, DNS processing stops and just the name is returned. The most common use is for implementing reverse DNS lookups, but other uses include such things as DNS-SD.\nSOA - Start of Authority record Specifies authoritative information about a DNS zone, including the primary name server, the email of the domain administrator, the domain serial number, and several timers relating to refreshing the zone.\nSRV - Service locator Generalized service location record, used for newer protocols instead of creating protocol-specific records such as MX.\nTXT - Text Record Originally for arbitrary human-readable text in a DNS record. Since the early 1990s, however, this record more often carries machine-readable data, such as specified by RFC 1464, opportunistic encryption Sender Policy Framework, DKIM, DMARC, DNS-SD, etc.\n"
},
{
	"uri": "/wiki/open-mail-relay/",
	"title": "Open Mail Relay",
	"tags": [],
	"description": "",
	"content": "An open mail relay is an SMTP server configured in such a way that it allows anyone on the Internet to send e-mail through it, not just mail destined to or originating from known users. This used to be the default configuration in many mail servers; indeed, it was the way the Internet was initially set up, but open mail relays have become unpopular because of their exploitation by spammers and worms. Many relays were closed, or were placed on blacklists by other servers.\nFurther information: Wikipedia\n"
},
{
	"uri": "/",
	"title": "PI Company",
	"tags": [],
	"description": "",
	"content": " Knowledgebase Welcome here! I have planned a long time ago to create this site. Now I have some free time so finally I\u0026rsquo;ve started. Feel free to use it, and if you find any mistakes please drop me a mail or use the EDIT button, and create a pull request!\nThank you,\nand have fun: Gyula, Paal \u0026lt;paalgyula@paalgyula.com\u0026gt;\n"
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]